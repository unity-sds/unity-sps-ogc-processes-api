# coding: utf-8

"""
    OGC API - Processes

    Example API Definition for OGC API - Processes

    The version of the OpenAPI document: 0.1
    Contact: info@ogc.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any, ClassVar, Dict, List, Optional, Union

from pydantic import (
    BaseModel,
    Field,
    StrictBool,
    StrictFloat,
    StrictInt,
    StrictStr,
    field_validator,
)
from typing_extensions import Annotated

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class SchemaOneOf(BaseModel):
    """
    SchemaOneOf
    """  # noqa: E501

    title: Optional[StrictStr] = None
    multiple_of: Optional[
        Union[
            Annotated[float, Field(strict=True, gt=0)],
            Annotated[int, Field(strict=True, gt=0)],
        ]
    ] = Field(default=None, alias="multipleOf")
    maximum: Optional[Union[StrictFloat, StrictInt]] = None
    exclusive_maximum: Optional[StrictBool] = Field(default=False, alias="exclusiveMaximum")
    minimum: Optional[Union[StrictFloat, StrictInt]] = None
    exclusive_minimum: Optional[StrictBool] = Field(default=False, alias="exclusiveMinimum")
    max_length: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, alias="maxLength")
    min_length: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=0, alias="minLength")
    pattern: Optional[StrictStr] = None
    max_items: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, alias="maxItems")
    min_items: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=0, alias="minItems")
    unique_items: Optional[StrictBool] = Field(default=False, alias="uniqueItems")
    max_properties: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(
        default=None, alias="maxProperties"
    )
    min_properties: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(
        default=0, alias="minProperties"
    )
    required: Optional[Annotated[List[StrictStr], Field(min_length=1)]] = None
    enum: Optional[Annotated[List[Dict[str, Any]], Field(min_length=1)]] = None
    type: Optional[StrictStr] = None
    is_not: Optional[Schema1] = Field(default=None, alias="not")
    all_of: Optional[List[Schema1]] = Field(default=None, alias="allOf")
    one_of: Optional[List[Schema1]] = Field(default=None, alias="oneOf")
    any_of: Optional[List[Schema1]] = Field(default=None, alias="anyOf")
    items: Optional[Schema1] = None
    properties: Optional[Dict[str, Schema1]] = None
    additional_properties: Optional[SchemaOneOfAdditionalProperties] = Field(
        default=None, alias="additionalProperties"
    )
    description: Optional[StrictStr] = None
    format: Optional[StrictStr] = None
    default: Optional[Dict[str, Any]] = None
    nullable: Optional[StrictBool] = False
    read_only: Optional[StrictBool] = Field(default=False, alias="readOnly")
    write_only: Optional[StrictBool] = Field(default=False, alias="writeOnly")
    example: Optional[Dict[str, Any]] = None
    deprecated: Optional[StrictBool] = False
    content_media_type: Optional[StrictStr] = Field(default=None, alias="contentMediaType")
    content_encoding: Optional[StrictStr] = Field(default=None, alias="contentEncoding")
    content_schema: Optional[StrictStr] = Field(default=None, alias="contentSchema")
    __properties: ClassVar[List[str]] = [
        "title",
        "multipleOf",
        "maximum",
        "exclusiveMaximum",
        "minimum",
        "exclusiveMinimum",
        "maxLength",
        "minLength",
        "pattern",
        "maxItems",
        "minItems",
        "uniqueItems",
        "maxProperties",
        "minProperties",
        "required",
        "enum",
        "type",
        "not",
        "allOf",
        "oneOf",
        "anyOf",
        "items",
        "properties",
        "additionalProperties",
        "description",
        "format",
        "default",
        "nullable",
        "readOnly",
        "writeOnly",
        "example",
        "deprecated",
        "contentMediaType",
        "contentEncoding",
        "contentSchema",
    ]

    @field_validator("type")
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ("array", "boolean", "integer", "number", "object", "string"):
            raise ValueError(
                "must be one of enum values ('array', 'boolean', 'integer', 'number', 'object', 'string')"
            )
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of SchemaOneOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={},
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of is_not
        if self.is_not:
            _dict["not"] = self.is_not.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in all_of (list)
        _items = []
        if self.all_of:
            for _item in self.all_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict["allOf"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in one_of (list)
        _items = []
        if self.one_of:
            for _item in self.one_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict["oneOf"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in any_of (list)
        _items = []
        if self.any_of:
            for _item in self.any_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict["anyOf"] = _items
        # override the default output from pydantic by calling `to_dict()` of items
        if self.items:
            _dict["items"] = self.items.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in properties (dict)
        _field_dict = {}
        if self.properties:
            for _key in self.properties:
                if self.properties[_key]:
                    _field_dict[_key] = self.properties[_key].to_dict()
            _dict["properties"] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of additional_properties
        if self.additional_properties:
            _dict["additionalProperties"] = self.additional_properties.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of SchemaOneOf from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "title": obj.get("title"),
                "multipleOf": obj.get("multipleOf"),
                "maximum": obj.get("maximum"),
                "exclusiveMaximum": (
                    obj.get("exclusiveMaximum") if obj.get("exclusiveMaximum") is not None else False
                ),
                "minimum": obj.get("minimum"),
                "exclusiveMinimum": (
                    obj.get("exclusiveMinimum") if obj.get("exclusiveMinimum") is not None else False
                ),
                "maxLength": obj.get("maxLength"),
                "minLength": (obj.get("minLength") if obj.get("minLength") is not None else 0),
                "pattern": obj.get("pattern"),
                "maxItems": obj.get("maxItems"),
                "minItems": (obj.get("minItems") if obj.get("minItems") is not None else 0),
                "uniqueItems": (obj.get("uniqueItems") if obj.get("uniqueItems") is not None else False),
                "maxProperties": obj.get("maxProperties"),
                "minProperties": (obj.get("minProperties") if obj.get("minProperties") is not None else 0),
                "required": obj.get("required"),
                "enum": obj.get("enum"),
                "type": obj.get("type"),
                "not": (Schema1.from_dict(obj.get("not")) if obj.get("not") is not None else None),
                "allOf": (
                    [Schema1.from_dict(_item) for _item in obj.get("allOf")]
                    if obj.get("allOf") is not None
                    else None
                ),
                "oneOf": (
                    [Schema1.from_dict(_item) for _item in obj.get("oneOf")]
                    if obj.get("oneOf") is not None
                    else None
                ),
                "anyOf": (
                    [Schema1.from_dict(_item) for _item in obj.get("anyOf")]
                    if obj.get("anyOf") is not None
                    else None
                ),
                "items": (Schema1.from_dict(obj.get("items")) if obj.get("items") is not None else None),
                "properties": (
                    dict((_k, Schema1.from_dict(_v)) for _k, _v in obj.get("properties").items())
                    if obj.get("properties") is not None
                    else None
                ),
                "additionalProperties": (
                    SchemaOneOfAdditionalProperties.from_dict(obj.get("additionalProperties"))
                    if obj.get("additionalProperties") is not None
                    else None
                ),
                "description": obj.get("description"),
                "format": obj.get("format"),
                "default": obj.get("default"),
                "nullable": (obj.get("nullable") if obj.get("nullable") is not None else False),
                "readOnly": (obj.get("readOnly") if obj.get("readOnly") is not None else False),
                "writeOnly": (obj.get("writeOnly") if obj.get("writeOnly") is not None else False),
                "example": obj.get("example"),
                "deprecated": (obj.get("deprecated") if obj.get("deprecated") is not None else False),
                "contentMediaType": obj.get("contentMediaType"),
                "contentEncoding": obj.get("contentEncoding"),
                "contentSchema": obj.get("contentSchema"),
            }
        )
        return _obj


from unity_sps_ogc_processes_api.models.schema1 import Schema1
from unity_sps_ogc_processes_api.models.schema_one_of_additional_properties import (
    SchemaOneOfAdditionalProperties,
)

# TODO: Rewrite to not use raise_errors
SchemaOneOf.model_rebuild(raise_errors=False)
