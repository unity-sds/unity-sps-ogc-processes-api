# generated by datamodel-codegen:
#   filename:  ogcapi-processes.yaml
#   timestamp: 2024-03-19T22:13:14+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Union

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, PositiveFloat, RootModel, confloat, conint


class BaseSchema(BaseModel):
    model_config = ConfigDict(use_enum_values=True, from_attributes=True)


class ConfClasses(BaseSchema):
    conformsTo: List[str]


class Link(BaseSchema):
    href: str
    rel: Optional[str] = Field(None, json_schema_extra={"example": "service"})
    type: Optional[str] = Field(None, json_schema_extra={"example": "application/json"})
    hreflang: Optional[str] = Field(None, json_schema_extra={"example": "en"})
    title: Optional[str] = None


class LandingPage(BaseSchema):
    title: Optional[str] = Field(None, json_schema_extra={"example": "Example processing server"})
    description: Optional[str] = Field(
        None,
        json_schema_extra={"example": "Example server implementing the OGC API - Processes 1.0 Standard"},
    )
    attribution: Optional[str] = Field(
        None,
        description="The `attribution` should be short and intended for presentation to a user, for example, in a corner of a map. Parts of the text can be links to other resources if additional information is needed. The string can include HTML markup.",
        title="attribution for the Processes API",
    )
    links: List[Link]


class Exception(BaseSchema):
    model_config = ConfigDict(extra="allow")

    type: str
    title: Optional[str] = None
    status: Optional[int] = None
    detail: Optional[str] = None
    instance: Optional[str] = None


class Crs(Enum):
    http___www_opengis_net_def_crs_OGC_1_3_CRS84 = "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
    http___www_opengis_net_def_crs_OGC_0_CRS84h = "http://www.opengis.net/def/crs/OGC/0/CRS84h"


class GridItem(BaseSchema):
    coordinates: Optional[List[Union[str, float]]] = Field(
        None,
        description="List of coordinates along the dimension for which data organized as an irregular grid in the collection is available\n(e.g., 2, 10, 80, 100).",
        json_schema_extra={"example": [2, 10, 80, 100]},
        min_length=1,
    )
    cellsCount: Optional[int] = Field(
        None,
        description="Number of samples available along the dimension for data organized as a regular grid.\nFor values representing the whole area of contiguous cells spanning _resolution_ units along the dimension, this will be (_upperBound_ - _lowerBound_) / _resolution_.\nFor values representing infinitely small point cells spaced by _resolution_ units along the dimension, this will be (_upperBound_ - _lowerBound_) / _resolution_ + 1.",
        json_schema_extra={"example": 50},
    )
    resolution: Optional[Union[str, float]] = Field(
        None,
        description="Resolution of regularly gridded data along the dimension in the collection",
        json_schema_extra={"example": 0.0006866455078},
    )


class Spatial(BaseSchema):
    bbox: Optional[List[List[float]]] = Field(
        None,
        description="One or more bounding boxes that describe the spatial extent of the dataset.\nIn the Core only a single bounding box is supported.\n\nExtensions may support additional areas.\nThe first bounding box describes the overall spatial\nextent of the data. All subsequent bounding boxes describe\nmore precise bounding boxes, e.g., to identify clusters of data.\nClients only interested in the overall spatial extent will\nonly need to access the first item in each array.",
        min_length=1,
    )
    crs: Optional[Crs] = Field(
        "http://www.opengis.net/def/crs/OGC/1.3/CRS84",
        description="Coordinate reference system of the coordinates in the spatial extent\n(property `bbox`). The default reference system is WGS 84 longitude/latitude.\nIn the Core the only other supported coordinate reference system is\nWGS 84 longitude/latitude/ellipsoidal height for coordinates with height.\nExtensions may support additional coordinate reference systems and add\nadditional enum values.",
    )
    grid: Optional[List[GridItem]] = Field(
        None,
        description="Provides information about the limited availability of data within the collection organized\nas a grid (regular or irregular) along each spatial dimension.",
        max_length=3,
        min_length=2,
    )


class IntervalItem(RootModel):
    root: List[Any] = Field(
        ...,
        description="Begin and end times of the time interval. The timestamps are in the\ntemporal coordinate reference system specified in `trs`. By default\nthis is the Gregorian calendar.\n\nThe value `null` for start or end time is supported and indicates a half-bounded time interval.",
        json_schema_extra={"example": ["2011-11-11T12:22:11Z", None]},
    )


class Trs(Enum):
    http___www_opengis_net_def_uom_ISO_8601_0_Gregorian = (
        "http://www.opengis.net/def/uom/ISO-8601/0/Gregorian"
    )


class Grid(BaseSchema):
    coordinates: Optional[List[str]] = Field(
        None,
        description='List of coordinates along the temporal dimension for which data organized as an irregular grid in the collection is available\n(e.g., "2017-11-14T09:00Z","2017-11-14T12:00Z","2017-11-14T15:00Z","2017-11-14T18:00Z","2017-11-14T21:00Z").',
        json_schema_extra={"example": [["2020-11-12T12:15Z", "2020-11-12T12:30Z", "2020-11-12T12:45Z"]]},
        min_length=1,
    )
    cellsCount: Optional[int] = Field(
        None,
        description="Number of samples available along the temporal dimension for data organized as a regular grid.\nFor values representing the whole area of contiguous cells spanning _resolution_ units along the dimension, this will be (_upperBound_ - _lowerBound_) / _resolution_.\nFor values representing infinitely small point cells spaced by _resolution_ units along the dimension, this will be (_upperBound_ - _lowerBound_) / _resolution_ + 1.",
        json_schema_extra={"example": 50},
    )
    resolution: Optional[Union[str, float]] = Field(
        None,
        description="Resolution of regularly gridded data along the temporal dimension in the collection",
        json_schema_extra={"example": "PT1H"},
    )


class Temporal(BaseSchema):
    interval: Optional[List[IntervalItem]] = Field(
        None,
        description="One or more time intervals that describe the temporal extent of the dataset.\nIn the Core only a single time interval is supported.\n\nExtensions may support multiple intervals.\nThe first time interval describes the overall\ntemporal extent of the data. All subsequent time intervals describe\nmore precise time intervals, e.g., to identify clusters of data.\nClients only interested in the overall extent will only need\nto access the first item in each array.",
        min_length=1,
    )
    trs: Optional[Trs] = Field(
        "http://www.opengis.net/def/uom/ISO-8601/0/Gregorian",
        description="Coordinate reference system of the coordinates in the temporal extent\n(property `interval`). The default reference system is the Gregorian calendar.\nIn the Core this is the only supported temporal coordinate reference system.\nExtensions may support additional temporal coordinate reference systems and add\nadditional enum values.",
    )
    grid: Optional[Grid] = Field(
        None,
        description="Provides information about the limited availability of data within the collection organized as a grid (regular or irregular) along the temporal dimension.",
    )


class Extent(BaseSchema):
    spatial: Optional[Spatial] = Field(None, description="The spatial extent of the data in the collection.")
    temporal: Optional[Temporal] = Field(
        None, description="The temporal extent of the features in the collection."
    )


class DataType1(Enum):
    map = "map"
    vector = "vector"
    coverage = "coverage"


class DataType(RootModel):
    root: Union[str, DataType1]


class Crs2(BaseSchema):
    uri: AnyUrl = Field(..., description="Reference to one coordinate reference system (CRS)")


class Wkt(BaseSchema):
    pass


class Crs3(BaseSchema):
    wkt: Wkt


class Crs4(BaseSchema):
    referenceSystem: Dict[str, Any] = Field(
        ...,
        description="A reference system data structure as defined in the MD_ReferenceSystem of the ISO 19115",
    )


class CrsModel(RootModel):
    root: Union[str, Union[Crs2, Crs3, Crs4]] = Field(..., title="CRS")


class TimeStamp(RootModel):
    root: datetime = Field(
        ...,
        description="This property indicates the time and date when the response was generated using RFC 3339 notation.",
        json_schema_extra={"example": "2017-08-17T08:05:32Z"},
    )


class NumberReturned(RootModel):
    root: conint(ge=0) = Field(
        ...,
        description='The number of features in the feature collection.\nA server may omit this information in a response, if the information\nabout the number of features is not known or difficult to compute.\nIf the value is provided, the value shall be identical to the number\nof items in the "features" array.',
        json_schema_extra={"example": 10},
    )


class NumberMatched(RootModel):
    root: conint(ge=0) = Field(
        ...,
        description="The number of features of the feature type that match the selection\nparameters like `bbox`.",
        json_schema_extra={"example": 127},
    )


class Type(Enum):
    enum = "enum"


class Enumeration(BaseSchema):
    type: Type
    enum: List[str]


class ProcessesList(Enum):
    RenderMap = "RenderMap"
    ElevationContours = "ElevationContours"
    OSMERE = "OSMERE"


class Metadata1(Link):
    role: Optional[str] = None


class Metadata2(BaseSchema):
    role: Optional[str] = None
    title: Optional[str] = None
    lang: Optional[str] = None
    value: Optional[Union[str, Dict[str, Any]]] = None


class Metadata(RootModel):
    root: Union[Metadata1, Metadata2]


class JobControlOptions(Enum):
    sync_execute = "sync-execute"
    async_execute = "async-execute"
    dismiss = "dismiss"


class ValuePassingEnum(Enum):
    byValue = "byValue"
    byReference = "byReference"


class MaxOccurs(Enum):
    unbounded = "unbounded"


class Type1(Enum):
    array = "array"
    boolean = "boolean"
    integer = "integer"
    number = "number"
    object = "object"
    string = "string"


class Reference(BaseSchema):
    model_config = ConfigDict(extra="forbid")

    field_ref: str = Field(..., alias="$ref")


class Type2(Enum):
    process = "process"


class StatusCode(Enum):
    accepted = "accepted"
    running = "running"
    successful = "successful"
    failed = "failed"
    dismissed = "dismissed"


class Crs5(Enum):
    http___www_opengis_net_def_crs_OGC_1_3_CRS84 = "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
    http___www_opengis_net_def_crs_OGC_0_CRS84h = "http://www.opengis.net/def/crs/OGC/0/CRS84h"


class Bbox(BaseSchema):
    bbox: List[float]
    crs: Optional[Union[Crs5, AnyUrl]] = "http://www.opengis.net/def/crs/OGC/1.3/CRS84"


class BinaryInputValue(RootModel):
    root: str


class InputValueNoObject(RootModel):
    root: Union[str, float, int, bool, List, BinaryInputValue, Bbox]


class Format(BaseSchema):
    mediaType: Optional[str] = None
    encoding: Optional[str] = None
    schema_: Optional[Union[str, Dict[str, Any]]] = Field(None, alias="schema")


class InputValue(RootModel):
    root: Union[InputValueNoObject, Dict[str, Any]]


class Output(BaseSchema):
    format: Optional[Format] = None


class Subscriber(BaseSchema):
    successUri: AnyUrl
    inProgressUri: Optional[AnyUrl] = None
    failedUri: Optional[AnyUrl] = None


class Results(RootModel):
    root: Any


class Type3(Enum):
    docker = "docker"
    oci = "oci"
    catalog = "catalog"


class Deployment(Enum):
    local = "local"
    remote = "remote"
    hpc = "hpc"
    cloud = "cloud"


class Config(BaseSchema):
    model_config = ConfigDict(extra="allow")

    cpuMin: Optional[confloat(ge=1.0)] = Field(
        None, description="Minimum number of CPUs required to run the process (unit is CPU core)."
    )
    cpuMax: Optional[float] = Field(
        None, description="Maximum number of CPU dedicated to the process (unit is CPU core)"
    )
    memoryMin: Optional[float] = Field(
        None, description="Minimum RAM memory required to run the application (unit is GB)"
    )
    memoryMax: Optional[float] = Field(
        None, description="Maximum RAM memory dedicated to the application (unit is GB)"
    )
    storageTempMin: Optional[float] = Field(
        None, description="Minimum required temporary storage size (unit is GB)"
    )
    storageOutputsMin: Optional[float] = Field(
        None, description="Minimum required output storage size (unit is GB)"
    )
    jobTimeout: Optional[float] = Field(None, description="Timeout delay for a job execution (in seconds)")


class ExecutionUnit(BaseSchema):
    model_config = ConfigDict(extra="allow")

    type: Type3 = Field(..., description="Type of execution unit.")
    image: str = Field(..., description="Container image reference for the execution unit.")
    deployment: Optional[Deployment] = Field(
        None, description="Deployment information for the execution unit."
    )
    config: Optional[Config] = Field(
        None, description="Hardware requirements and configuration properties for executing the process."
    )


class ExtentUad(Extent):
    pass


class DescriptionType(BaseSchema):
    title: Optional[str] = None
    description: Optional[str] = None
    keywords: Optional[List[str]] = None
    metadata: Optional[List[Metadata]] = None


class StatusInfo(BaseSchema):
    processID: Optional[str] = None
    type: Type2
    jobID: str
    status: StatusCode
    message: Optional[str] = None
    exception: Optional[Exception] = None
    created: Optional[datetime] = None
    started: Optional[datetime] = None
    finished: Optional[datetime] = None
    updated: Optional[datetime] = None
    progress: Optional[conint(ge=0, le=100)] = None
    links: Optional[List[Link]] = None


class BboxProcesses(RootModel):
    root: Bbox


class Execute(BaseSchema):
    inputs: Optional[Any] = None
    outputs: Optional[Any] = None
    subscriber: Optional[Subscriber] = None


class QualifiedInputValue(Format):
    value: InputValue


class OgcapppkgArray(RootModel):
    root: List[Union[ExecutionUnit, Link, QualifiedInputValue]]


class CollectionInfo(BaseSchema):
    id: str = Field(
        ...,
        description="identifier of the collection used, for example, in URIs",
        json_schema_extra={"example": "dem"},
    )
    title: Optional[str] = Field(
        None,
        description="human readable title of the collection",
        json_schema_extra={"example": "Digital Elevation Model"},
    )
    description: Optional[str] = Field(
        None,
        description="a description of the data in the collection",
        json_schema_extra={"example": "A Digital Elevation Model."},
    )
    links: List[Link] = Field(
        ...,
        json_schema_extra={
            "example": [
                {
                    "href": "http://data.example.org/collections/dem?f=json",
                    "rel": "self",
                    "type": "application/json",
                    "title": "Digital Elevation Model",
                },
                {
                    "href": "http://data.example.org/collections/dem?f=html",
                    "rel": "alternate",
                    "type": "application/json",
                    "title": "Digital Elevation Model",
                },
                {
                    "href": "http://data.example.org/collections/dem/coverage",
                    "rel": "coverage",
                    "type": "image/tiff; application=geotiff",
                    "title": "Digital Elevation Model",
                },
                {
                    "href": "http://data.example.org/collections/dem/coverage/domainset",
                    "rel": "domainset",
                    "type": "application/json",
                    "title": "Digital Elevation Model",
                },
                {
                    "href": "http://data.example.org/collections/dem/coverage/rangetype",
                    "rel": "rangetype",
                    "type": "application/json",
                    "title": "Digital Elevation Model",
                },
                {
                    "href": "http://data.example.org/collections/dem/coverage/metadata",
                    "rel": "metadata",
                    "type": "application/json",
                    "title": "Digital Elevation Model",
                },
            ]
        },
    )
    extent: Optional[ExtentUad] = None
    itemType: Optional[str] = Field(
        "unknown",
        description="indicator about the type of the items in the collection if the collection has an accessible /collections/{collectionId}/items endpoint",
    )
    crs: Optional[List[str]] = Field(
        ["http://www.opengis.net/def/crs/OGC/1.3/CRS84"],
        description="the list of coordinate reference systems supported by the API; the first item is the default coordinate reference system",
        json_schema_extra={
            "example": [
                "http://www.opengis.net/def/crs/OGC/1.3/CRS84",
                "http://www.opengis.net/def/crs/EPSG/0/4326",
            ]
        },
    )
    dataType: Optional[DataType] = None
    geometryDimension: Optional[conint(ge=0, le=3)] = Field(
        None,
        description="The geometry dimension of the features shown in this layer (0: points, 1: curves, 2: surfaces, 3: solids), unspecified: mixed or unknown",
    )
    minScaleDenominator: Optional[float] = Field(
        None, description="Minimum scale denominator for usage of the collection"
    )
    maxScaleDenominator: Optional[float] = Field(
        None, description="Maximum scale denominator for usage of the collection"
    )
    minCellSize: Optional[float] = Field(None, description="Minimum cell size for usage of the collection")
    maxCellSize: Optional[float] = Field(None, description="Maximum cell size for usage of the collection")


class ProcessSummary(DescriptionType):
    id: str
    version: str
    jobControlOptions: Optional[List[JobControlOptions]] = None
    links: Optional[List[Link]] = None


class Process(ProcessSummary):
    inputs: Optional[List[InputValue]] = None
    outputs: Optional[List[InputValue]] = None


class ProcessList(BaseSchema):
    processes: List[ProcessSummary]
    links: List[Link]


class JobList(BaseSchema):
    jobs: List[StatusInfo]
    links: List[Link]


class InlineOrRefData(RootModel):
    root: Union[InputValueNoObject, QualifiedInputValue, Link]


class Ogcapppkg(BaseSchema):
    processDescription: Optional[Process] = None
    executionUnit: Union[ExecutionUnit, Link, QualifiedInputValue, OgcapppkgArray]


class StaticIndicator(ProcessSummary):
    mutable: Optional[bool] = True


class Collections(BaseSchema):
    links: List[Link]
    timeStamp: Optional[datetime] = None
    numberMatched: Optional[conint(ge=0)] = Field(None, json_schema_extra={"example": 1})
    numberReturned: Optional[conint(ge=0)] = Field(None, json_schema_extra={"example": 1})
    collections: List[CollectionInfo]


class Input(RootModel):
    root: Union[InlineOrRefData, List[InlineOrRefData]]


class InputDescription(DescriptionType):
    valuePassing: Optional[List[ValuePassingEnum]] = ["byValue", "byReference"]
    minOccurs: Optional[int] = 1
    maxOccurs: Optional[Union[int, MaxOccurs]] = None
    schema_: Schema = Field(..., alias="schema")


class Schema1(BaseSchema):
    model_config = ConfigDict(extra="forbid")

    title: Optional[str] = None
    multipleOf: Optional[PositiveFloat] = None
    maximum: Optional[float] = None
    exclusiveMaximum: Optional[bool] = False
    minimum: Optional[float] = None
    exclusiveMinimum: Optional[bool] = False
    maxLength: Optional[conint(ge=0)] = None
    minLength: Optional[conint(ge=0)] = 0
    pattern: Optional[str] = None
    maxItems: Optional[conint(ge=0)] = None
    minItems: Optional[conint(ge=0)] = 0
    uniqueItems: Optional[bool] = False
    maxProperties: Optional[conint(ge=0)] = None
    minProperties: Optional[conint(ge=0)] = 0
    required: Optional[Set[str]] = Field(None, min_length=1)
    enum: Optional[List] = Field(None, min_length=1)
    type: Optional[Type1] = None
    not_: Optional[Schema] = Field(None, alias="not")
    allOf: Optional[List[Schema]] = None
    oneOf: Optional[List[Schema]] = None
    anyOf: Optional[List[Schema]] = None
    items: Optional[Schema] = None
    properties: Optional[Dict[str, Schema]] = None
    additionalProperties: Optional[Union[Schema, bool]] = True
    description: Optional[str] = None
    format: Optional[str] = None
    default: Optional[Any] = None
    nullable: Optional[bool] = False
    readOnly: Optional[bool] = False
    writeOnly: Optional[bool] = False
    example: Optional[Any] = None
    deprecated: Optional[bool] = False
    contentMediaType: Optional[str] = None
    contentEncoding: Optional[str] = None
    contentSchema: Optional[str] = None


class Schema(RootModel):
    root: Union[Reference, Schema1]


class OutputDescription(DescriptionType):
    schema_: Schema = Field(..., alias="schema")


InputDescription.model_rebuild()
Schema1.model_rebuild()
