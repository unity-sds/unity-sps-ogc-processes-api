# generated by fastapi-codegen:
#   filename:  ogcapi-processes.yaml
#   timestamp: 2024-02-16T19:06:21+00:00

from __future__ import annotations

from functools import lru_cache

from fastapi import Body, FastAPI, HTTPException

from .config import Settings
from .database import SessionLocal, engine, models

models.Base.metadata.create_all(bind=engine)

from .schemas.ogc_processes import (
    ConfClasses,
    Execute,
    JobList,
    LandingPage,
    Link,
    Process,
    ProcessList,
    Results,
    StatusCode,
    StatusInfo,
    Type2,
)

app = FastAPI(
    version="Placeholder",
    title="Placeholder",
    description="Placeholder",
    contact={"name": "Placeholder", "email": "Placeholder"},
    license={"name": "Placeholder", "url": "Placeholder"},
    servers=[],
)


@lru_cache
def get_settings():
    return Settings()


# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


processes_data = [Process(id="sample-process", version="1.0")]

jobs_data = [
    StatusInfo(
        jobID="job1",
        type=Type2.process,
        processID="sample-process",
        status=StatusCode.running,
    ),
    StatusInfo(
        jobID="job2",
        type=Type2.process,
        processID="sample-process",
        status=StatusCode.successful,
    ),
]


@app.get("/", response_model=LandingPage)
async def landing_page():
    return LandingPage(
        title="Unity SPS Processing Server",
        description="Server implementing the OGC API - Processes 1.0 Standard",
        links=[Link(href="/conformance"), Link(href="/processes"), Link(href="/jobs")],
    )


@app.get("/conformance", response_model=ConfClasses)
async def conformance_declaration():
    return ConfClasses(
        conformsTo=["http://www.opengis.net/spec/ogcapi-processes-1/1.0/conf/ogc-process-description"]
    )


@app.get("/processes", response_model=ProcessList)
async def process_list():
    return ProcessList(processes=processes_data, links=[])


@app.get("/processes/{process_id}", response_model=Process)
async def process_description(process_id: str):
    filtered_processes = [process for process in processes_data if process.id == process_id]

    if len(filtered_processes) > 1:
        raise HTTPException(
            status_code=500,
            detail="Multiple processes found for given ID, which is an unexpected error.",
        )

    if not filtered_processes:
        raise HTTPException(status_code=404, detail="Process not found")

    return filtered_processes[0]


@app.get("/jobs", response_model=JobList)
async def job_list():
    job_list = JobList(jobs=jobs_data, links=[])
    return job_list


@app.post("/processes/{process_id}/execution", response_model=StatusInfo)
async def execute(process_id: str, process: Execute = Body(...)):
    raise HTTPException(status_code=501, detail="Not Implemented")


@app.get("/jobs/{job_id}", response_model=StatusInfo)
async def status(job_id: str):
    filtered_jobs = [job for job in jobs_data if job.jobID == job_id]

    if len(filtered_jobs) > 1:
        raise HTTPException(
            status_code=500,
            detail="Multiple jobs found for given ID, which is an unexpected error.",
        )

    if not filtered_jobs:
        raise HTTPException(status_code=404, detail="Process not found")

    return filtered_jobs[0]


@app.delete("/jobs/{job_id}", response_model=StatusInfo)
async def dismiss(job_id: str):
    raise HTTPException(status_code=501, detail="Not Implemented")


@app.get("/jobs/{job_id}/results", response_model=Results)
async def result(job_id: str):
    raise HTTPException(status_code=501, detail="Not Implemented")
