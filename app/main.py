# generated by fastapi-codegen:
#   filename:  ogcapi-processes.yaml
#   timestamp: 2024-02-16T19:06:21+00:00

from __future__ import annotations

from functools import lru_cache
from contextlib import asynccontextmanager

from fastapi import Body, FastAPI, HTTPException, Depends

from .config import Settings
from .database import SessionLocal, engine, models, crud
from sqlalchemy.orm import Session
from sqlalchemy.orm.exc import NoResultFound, MultipleResultsFound

from .schemas.ogc_processes import (
    ConfClasses,
    Execute,
    JobList,
    LandingPage,
    Link,
    Process,
    ProcessList,
    Results,
    StatusInfo,
    StatusCode
)


models.Base.metadata.create_all(bind=engine)  # Create database tables


# def create_initial_processes(db: Session):
#     # Check if data already exists
#     if db.query(models.Process).first() is None:
#         # Pre-populate the database
#         processes = [
#             models.Process(
#                 version="1.0",
#                 job_control_options={"option1": "value1"},
#                 links=[{"href": "http://example.com", "rel": "self"}],
#                 inputs={"input1": "data1"},
#                 outputs={"output1": "result1"}
#             ),
#             models.Process(
#                 version="1.1",
#                 job_control_options={"option2": "value2"},
#                 links=[{"href": "http://example.org", "rel": "self"}],
#                 inputs={"input2": "data2"},
#                 outputs={"output2": "result2"}
#             )
#         ]
#         for p in processes:
#             db_item = models.Process(**p.model_dump())
#             db.add(db_item)
#             db.commit()
#             print(p.model_dump)


# @asynccontextmanager
# async def lifespan(app: FastAPI):
#     db = SessionLocal()
#     create_initial_processes(db)
#     yield
#     db.close()


app = FastAPI(
    version="Placeholder",
    title="Placeholder",
    description="Placeholder",
    contact={"name": "Placeholder", "email": "Placeholder"},
    license={"name": "Placeholder", "url": "Placeholder"},
    servers=[],
    # lifespan=lifespan
)


@lru_cache
def get_settings():
    return Settings()


# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@app.get("/", response_model=LandingPage)
async def landing_page():
    return LandingPage(
        title="Unity SPS Processing Server",
        description="Server implementing the OGC API - Processes 1.0 Standard",
        links=[Link(href="/conformance"), Link(href="/processes"), Link(href="/jobs")],
    )


@app.get("/conformance", response_model=ConfClasses)
async def conformance_declaration():
    return ConfClasses(
        conformsto=["http://www.opengis.net/spec/ogcapi-processes-1/1.0/conf/ogc-process-description"]
    )


@app.post("/processes", response_model=Process)
async def deploy_process(db: Session = Depends(get_db), process: Process = Body(...)):
    try:
        crud.get_process(db, process.id)
        raise HTTPException(status_code=400, detail=f"Process with ID {process.id} not found")
    except MultipleResultsFound:
        raise HTTPException(
            status_code=500,
            detail=f"Multiple processes found with same ID {process.id}, data integrity error",
        )
    except NoResultFound:
        pass
    return crud.create_process(db, process)


@app.get("/processes", response_model=ProcessList)
async def process_list(db: Session = Depends(get_db)):
    processes = crud.get_processes(db)
    links = [
        Link(href="/processes", rel="self", type="application/json", hreflang=None, title="List of processes")
    ]
    return ProcessList(processes=processes, links=links)


@app.get("/processes/{process_id}", response_model=Process)
async def process_description(process_id: str, db: Session = Depends(get_db)):
    try:
        process = crud.get_process(db, process_id)  # Assume this should only return one or no results
    except NoResultFound:
        raise HTTPException(status_code=404, detail=f"Process with ID {process_id} not found")
    except MultipleResultsFound:
        raise HTTPException(
            status_code=500,
            detail=f"Multiple processes found with same ID {process_id}, data integrity error",
        )
    return process


@app.get("/jobs", response_model=JobList)
async def job_list(db: Session = Depends(get_db)):
    jobs = crud.get_jobs(db)
    links = [Link(href="/jobs", rel="self", type="application/json", hreflang=None, title="List of jobs")]
    return JobList(jobs=jobs, links=links)


@app.post("/processes/{process_id}/execution", response_model=StatusInfo)
async def execute(process_id: str, execute: Process = Body(...), db: Session = Depends(get_db)):
    try:
        crud.get_process(db, process_id)
    except NoResultFound:
        raise HTTPException(status_code=404, detail=f"Process with ID {process_id} not found")
    except MultipleResultsFound:
        raise HTTPException(
            status_code=500,
            detail=f"Multiple processes found with same ID {process_id}, data integrity error",
        )
    return crud.create_job(db, execute, process_id)


@app.get("/jobs/{job_id}", response_model=StatusInfo)
async def status(job_id: str, db: Session = Depends(get_db)):
    try:
        job = crud.get_job(db, job_id)  # Assume this should only return one or no results
    except NoResultFound:
        raise HTTPException(status_code=404, detail=f"Job with ID {job_id} not found")
    except MultipleResultsFound:
        raise HTTPException(
            status_code=500,
            detail=f"Multiple jobs found with same ID {job_id}, data integrity error",
        )
    return job


@app.delete("/jobs/{job_id}", response_model=StatusInfo)
async def dismiss(job_id: str, db: Session = Depends(get_db)):
    try:
        job = crud.get_job(db, job_id)  # Assume this should only return one or no results
    except NoResultFound:
        raise HTTPException(status_code=404, detail=f"Job with ID {job_id} not found")
    except MultipleResultsFound:
        raise HTTPException(
            status_code=500,
            detail=f"Multiple jobs found with same ID {job_id}, data integrity error",
        )
    crud.delete_job(db, job)
    job.status = StatusCode.dismissed
    return job


@app.get("/jobs/{job_id}/results", response_model=Results)
async def results(job_id: str, db: Session = Depends(get_db)):
    try:
        crud.get_job(db, job_id)
    except NoResultFound:
        raise HTTPException(status_code=404, detail=f"Job with ID {job_id} not found")
    except MultipleResultsFound:
        raise HTTPException(
            status_code=500,
            detail=f"Multiple jobs found with same ID {job_id}, data integrity error",
        )
    return crud.get_results(db, job_id)
